# 正则表达式

以 `(?` 开头标志特殊的功能，`(?:)` 分组不捕获、`(?=)` / `(?<=)` 环视。 

### 环视 lookaround

顺序环视 lookahead，逆序环视 lookbehind

- 肯定顺序环视 `(?=...)`，从左到右（零宽正向先行断言）positive lookahead
- 肯定逆序环视 `(?<=...)`，从右到左（零宽正向后行断言）positive lookbehind
- 否定顺序环视 `(?!)`
- 否定逆序环视 `(?<!)`

```perl
s/(?<=\bJeff)(?=s\b)/'/g # 替换 Jeffs 为 Jeff's
```

例：货币格式化

```perl
s/(?<=\d)(?=(?:\d{3})+$)/,/g # 每三位数字添加一个逗号，限于以数字结尾
s/(?<=\d)(?=(?:\d{3})+(?!\d))/,/g # 每三位数字添加一个逗号，更通用的解法
```

```perl
/(?<=\w)(?!\w)|(?<!\w)(?=\w)/ == /\b/
```

### 流派

POSIX(Portable Operating System Interface) 标准将正则表达式分为两个流派

- BREs: Basic Regular Expressions
- EREs: Extended Regular Expressions

| 特性 | BREs | EREs |
| --- | --- | --- |
| `.`, `^`, `$`,`[...]`, `[^...]` | ✅ | ✅ |
| “任意数目” 量词 | `*` | `*` |
| `+`, `?` 量词 | | `+`, `?` |
| 区间量词 | `\{min,max\}` | `{min,max}` |
| 分组 | `\(...\)` | `(...)` |
| 量词可否作用于括号 | ✅ | ✅ |
| 反向引用 | `\1` 到 `\9` | |
| 多选结构 | | ✅ |

- 匹配优先量词 `*`、`+`、`?`、`{num, num}`
- 区间 `{min, max}`
- 忽略优先量词 `*?`、`+?`、`??`、`{num, num}?`
- 占有优先量词 `*+`、`++`、`?+`、`{num, num}+`

### 引擎

- DFA（符合或不符合 POSIX 标准）
- 传统型 NFA（Perl、PHP、Java、.Net 等）
- POSIX NFA

NFA：表达式主导（Regex-Directed）
DFA：文本主导（Text-Directed）

#### DFA 与 NFA：能力的差异

NFA 引擎提供一些 DFA 不支持的功能：

- 捕获由括号内的子表达式匹配的文本，反向引用和后匹配信息
- 环视，以及其他复杂的零长度确认
- 非匹配优先的量词，以及有序的多选结构
- 占有优先量词和固化分组

#### 区分是否传统型 NFA

查看忽略优先量词是否支持。DFA 不支持忽略优先量词，POSIX NFA 中没有意义。
确认 `nfa|nfa not` 如果能匹配 `nfa not`，则要么是 POSIX NFA，要么是 DFA。

#### NFA 回溯

如果需要在 “进行尝试” 和 “跳过尝试” 之间选择，对于匹配优先量词，引擎会优先选择 “进行尝试”，而对于忽略优先量词，会选择 “跳过尝试”。

匹配优先量词（`*`、`+` 等），意味着 `The name "McDonald's" is said "makudonarudo" in Japanese` 对于 `".*"` 匹配到的结果是 `"McDonald's" is said "makudonarudo"`

忽略优先量词（`*?`、`+?` 等），意味着使用 `".*?"` 可以配到到正确的结果 `"McDonald's"`

例：匹配 DOM `<div>there is <div>a box</div> on the page</div>`

```
<div>((?!</?div>).)*</div>
```

例：保留三位小数

`s/(\.\d\d[1-9]?)\d*/$1/` 当数据本身是三位小数时替换是多余的。
`s/(\.\d\d[1-9]?)\d+/$1/` 当数据本身是三位小数时会被保留两位小数。

### 固化分组 `(?>...)`

在固化分组匹配结束时，它已经匹配的文本已经固化为一个单元，只能作为整体而保留或放弃。

`s/(\.\d\d(?>[1-9]?))\d+/$1`

例：无用的回溯

`^\w+:` 匹配 `Subject` 时，先匹配到末尾，发现不匹配后，再从右往左回溯到开始状态，即在 `\w` 中寻找 `:`，最后回溯完后失败。使用固化分组可以优化这里的效率。`^(?>\w+):`

### 用肯定环视来模拟固化分组

`(?>regex)` 用 `(?=(regex))\1` 来模拟

### 有序多选结构的陷进

DFA 和 POSIX NFA 确实有匹配优先的多选结构。但传统型 NFA 中，多选结构是按序排列的。

例：匹配日期 `Jan xx`，xx 可以取值 `01 - 31` 或 `1 - 31`

`Jan (0?[1-9]|[12][0-9])|(3[01])` 不正确，会使 `Jan 31 ...` 匹配到 `Jan 3`，而换一下顺序，`Jan ([12][0-9])|(3[01]|0?[1-9])` 可以解决

另外 `Jan (31|[123]0|[012]?[1-9])` 和 `Jan (0[1-9]|[12][0-9]?|3[0-1]?|[4-9])`

最左最长规则（The Longest-Leftmost）

例：传统型 NFA 用 `one(self)?(selfsufficient)?` 匹配 `oneselfsufficient`，首先匹配 `one`，然后匹配优先 `(self)?`，最后匹配优先 `(selfsufficient)?`，最后返回 `oneself`

